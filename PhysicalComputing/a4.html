<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, maximum-scale=1.0" />
    <title>A4: Libraries! - Sam Chen</title>
    <link href="style.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <h1>Assignment 4: Libraries!</h1>
    <div class="header">
      <img src="A3/LightLevels.gif" width="350" alt="LEDs turning off and lighting"/>
      <p>
        Left: A short gif of the servo changing position as I touch the capacitive sensor.
      </p>
    </div>
    <br>
    <p>
      <h2>
        Images:
      </h2>
      <img src="A3/circuit.jpg" width="350" alt="Top-down picture of a circuit">
      Picture of the circuit I used for this assignment. The photoresistor is connected to an
      analog pin, which turns the input voltage to a 10-bit value. This value is used to turn on
      a corresponding number of LEDs (0-3), with a high light level turning on all of the LEDS
      and a lower light level turning on some or none.<br>
      <br>
      <img src="A3/DIAGRAM.PNG" width="350" alt="Diagram of the circuit for this assignment">
      This diagram represents the above circuit, showing both the photoresistor and LEDs. The
      resistor values for the LEDs were chosen based on their maximum 20 mA current requirement,
      while the fixed resistor in the voltage divider was selected based on the maximum 75K Ω
      value of this photoresistor. The 100K Ω resistor ensures that a safe current level goes
      to the Arduino. At the divider, it's possible to read between 0 and 5 V due to the
      value of the photoresistor.<br>
    </p>
    <br>
    <p>
      <h2>
        Code:
      </h2>
      <pre><code>
        /*
        Uses a servo to indicate signal values from a basic capacitive sensor.
        Uses code from Paul Badger's capacitive sensor demo and the Arduino servo library
        */

        // Note: Carats removed from these lines to allow them to display in HTML
        #include Servo.h // Include servo library
        #include CapacitiveSensor.h // Include capacitive sensor library

        Servo myservo; // Servo object is used to control a specific servo
        int pos = 0; // Variable for storing servo position
        CapacitiveSensor sensor = CapacitiveSensor(4,2); // Capacitive sensor between pins 4 and 2
        int minVal = 1023; // Initial minimum sensor value
        int maxVal = 0; // Initial max sensor value
        int dataRange = 0; // Initial data range
        int mapVal = 0; // Initial mapped value

        void setup() {
          myservo.attach(9); // Sets up servo to attach to pin 9
          sensor.set_CS_AutocaL_Millis(0xFFFFFFFF); // Turns off automatic calibration
          Serial.begin(9600); // Identifies the serial monitor port
          while (millis() < 5000) { // Starts calibration period
            long calibData = sensor.capacitiveSensor(30); // Sensor output value
            if (calibData > maxVal) { // If current sensor output exceeds the max recorded value
              maxVal = calibData; // Sets the max value to the current output
            }
            if (calibData < minVal) { // If current sensor output exceeds the min recorded value
              minVal = calibData; // Sets the min value to the current output
            }
          }
          dataRange = maxVal - minVal; // Calculates the data range
        }

        void loop() {
          long sensorVal = sensor.capacitiveSensor(30); // Reads value from the sensor
          Serial.print("Original output: "); // Caption for console value
          Serial.print(sensorVal); // Print the original sensor value
          delay(100); // Delays measurements
          mapVal = map(sensorVal, minVal, maxVal, 0, 180); // Maps sensor value to servo position
          Serial.print("\t Mapped output: "); // Caption for mapped values
          Serial.println(mapVal); // Prints mapped value
          myservo.write(mapVal); // Writes mapped value to servo
          delay(5); // Additional delay
        }
      </code></pre>
    </p>
    <p>
      <h2>
        Responses:
      </h2>
      1.
    </p>
    <br>
    <p>
      2. A possible solution could include mapping inputs to the known correct range. For example,
      if a value is outside of a range, map it to be within the range using the map function.<br>
      Alternatively, limit values so that it is only recognized as valid if displayed a certain
      number of times/for a certain duration, so that the 1% error is discarded.
    </p>
    <br>
    <p>
      3. A way to address this could be to average the readings since they deviate higher and lower
      by an equal amount. For example, over blocks of short time periods average the readings and
      only utilize the averaged value. With a short period this would allow the readings to stay
      responsive but also minimize the random deviations.
    </p>
    <br>
    <p>
      4. I did not use AI tools while working on this assignment.
    </p>
  </body>
</html>